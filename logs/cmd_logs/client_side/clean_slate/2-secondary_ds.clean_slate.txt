>>> import demo.demo_secondary as ds
	-------- --------> [tuf/util.py]	>>Function:  [import_json()]:  Importing JSON
	-------- --------> [tuf/keys.py]	>>Function:  [check_crypto_libraries()]:  Checking crypto libraries required_libraries: [u'rsa', u'ed25519', u'general']
>>> ds.clean_slate()
	[demo/demo_secondary.py]	>>Function:  [clean_slate(use_new_keys, vin, ecu_serial, primary_host, primary_port)]:  Cleaning slate for vin: democar ecu_serial: TCUdemocar primary_host: None
	-------->[demo/__init__.py]	>>Action Perfomed:  [get_random_string()]:  Getting random string with length: 5
	-------->[demo/__init__.py]	>>Action Perfomed:  [import_public_key()]:  Importing public key keyname: timeserver
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_publickey_from_file()]:  Importing ed25519 publickey from file with filepath: /home/joan/Escriptori/TFM/TFM/demo/keys/timeserver.pub
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  Loading JSON file for filepath: /home/joan/Escriptori/TFM/TFM/demo/keys/timeserver.pub
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_publickey_from_file()]:  returning 
	[demo/demo_secondary.py]	>>Function:  [clean_slate(use_new_keys, vin, ecu_serial, primary_host, primary_port)]:  loading key_timeserver_pub: {u'keyval': {u'public': u'5d7750b208dfc7ade8f6106b9c3fa25162d5a184f302161e429f19a79e66a908'}, u'keytype': u'ed25519', u'keyid': '79c796d7e87389d1ebad04edce49faef611d139ee41ea9fb1931732afbfaac2e', u'keyid_hash_algorithms': [u'sha256', u'sha512']}
	[demo/demo_secondary.py]	>>Function:  [clean_slate(use_new_keys, vin, ecu_serial, primary_host, primary_port)]:  Creating FACTORY ECU FIRMWARE: {u'fileinfo': {u'hashes': {u'sha256': u'6b9f987226610bfed08b824c93bf8b2f59521fce9a2adef80c495f363c1c9c44', u'sha512': u'706c283972c5ae69864b199e1cdd9b4b8babc14f5a454d0fd4d3b35396a04ca0b40af731671b74020a738b5108a78deb032332c36d6ae9f31fae2f8a70f7e1ce'}, u'length': 37}, u'filepath': u'/secondary_firmware.txt'}
	[demo/demo_secondary.py]	>>Function:  [clean_slate(use_new_keys, vin, ecu_serial, primary_host, primary_port)]:  Load or generate the Private key for this SECONDARY ECU
	[demo/demo_secondary.py]	>>Function:  [load_or_generate_key(use_new_keys)]:  Loading or generating keys with use_new_keys: False
	-------->[demo/__init__.py]	>>Action Perfomed:  [import_public_key()]:  Importing public key keyname: secondary
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_publickey_from_file()]:  Importing ed25519 publickey from file with filepath: /home/joan/Escriptori/TFM/TFM/demo/keys/secondary.pub
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  Loading JSON file for filepath: /home/joan/Escriptori/TFM/TFM/demo/keys/secondary.pub
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_publickey_from_file()]:  returning 
	-------->[demo/__init__.py]	>>Action Perfomed:  [import_private_key()]:  Importing private key keyname: secondary
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_privatekey_from_file()]:  Importing ed25519 privatekey from file with filepath: /home/joan/Escriptori/TFM/TFM/demo/keys/secondary password: pw
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_privatekey_from_file()]: Store the encrypted contents of '/home/joan/Escriptori/TFM/TFM/demo/keys/secondary' prior to calling the decryption routine
	-------- --------> [tuf/keys.py]	>>Function:  [decrypt_key()]:  Return a string containing encrypted_key: 0f3a7539d153bdc221561d0060c5a1d0@@@@100000@@@@d956c47167fda8e315a7d6fbbdec2b2fd3f62ba338d205f01905a765e553e184@@@@f79e8c6ab9f7c343c704e114ff1fcfb3@@@@130ebcfecbe1e80502784681219cf4d70b26ee47f39da3526149bdf10a1e750d6e532e9ef129e26a4698545b97363a6f9e4132fcaef4abda179bb46ed036dd34c18efee4ff4fc7c90eeb26ecaccdeba0706879185c5724d5b7091020bed77b758eef08f83095ce848cd5962d296175a87a8235902b6dbcafa0f1544f1445cd146f92eb3b79da9c323108a050de9c953d1473a954bd8d419e60981790087c5bfaff09730c9c079e582e4f51f658c509149f7f97e6a343a410883546ed3d455f4a0920b1c5c22026196ed44823e67ddb350fa0dfa6dd13f5739b6fffc1c1da1f12e525ea78449319e5fad6ba9f1249301c1587357a64db1aa8b58495fd07db457151047ed2fc69f96d839d393d in non-encrypted form, using passphrase: pw
	-------- --------> [tuf/keys.py]	>>Function:  [check_crypto_libraries()]:  Checking crypto libraries required_libraries: [u'general']
	--------> [tuf/pycrypto_keys.py]	>>Function:  [decrypt_key()]:  Decrypting encrypted_key: 0f3a7539d153bdc221561d0060c5a1d0@@@@100000@@@@d956c47167fda8e315a7d6fbbdec2b2fd3f62ba338d205f01905a765e553e184@@@@f79e8c6ab9f7c343c704e114ff1fcfb3@@@@130ebcfecbe1e80502784681219cf4d70b26ee47f39da3526149bdf10a1e750d6e532e9ef129e26a4698545b97363a6f9e4132fcaef4abda179bb46ed036dd34c18efee4ff4fc7c90eeb26ecaccdeba0706879185c5724d5b7091020bed77b758eef08f83095ce848cd5962d296175a87a8235902b6dbcafa0f1544f1445cd146f92eb3b79da9c323108a050de9c953d1473a954bd8d419e60981790087c5bfaff09730c9c079e582e4f51f658c509149f7f97e6a343a410883546ed3d455f4a0920b1c5c22026196ed44823e67ddb350fa0dfa6dd13f5739b6fffc1c1da1f12e525ea78449319e5fad6ba9f1249301c1587357a64db1aa8b58495fd07db457151047ed2fc69f96d839d393d password: pw
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_decrypt()]:  Decrypting file_contents: 0f3a7539d153bdc221561d0060c5a1d0@@@@100000@@@@d956c47167fda8e315a7d6fbbdec2b2fd3f62ba338d205f01905a765e553e184@@@@f79e8c6ab9f7c343c704e114ff1fcfb3@@@@130ebcfecbe1e80502784681219cf4d70b26ee47f39da3526149bdf10a1e750d6e532e9ef129e26a4698545b97363a6f9e4132fcaef4abda179bb46ed036dd34c18efee4ff4fc7c90eeb26ecaccdeba0706879185c5724d5b7091020bed77b758eef08f83095ce848cd5962d296175a87a8235902b6dbcafa0f1544f1445cd146f92eb3b79da9c323108a050de9c953d1473a954bd8d419e60981790087c5bfaff09730c9c079e582e4f51f658c509149f7f97e6a343a410883546ed3d455f4a0920b1c5c22026196ed44823e67ddb350fa0dfa6dd13f5739b6fffc1c1da1f12e525ea78449319e5fad6ba9f1249301c1587357a64db1aa8b58495fd07db457151047ed2fc69f96d839d393d password: pw
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_decrypt()]:  Extracting salt, iterations, hmac, iv and ciphertext from encrypted_key
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_decrypt()]:  Regenerating the derived key from password using salt and iterations
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_generate_derived_key()]:  Generate a derived key by feeding password: pw salt: ? iterations: ?
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_generate_derived_key()]:  INFO: 'dkLen' is the desired key length (_AES_KEY_SIZE = 32).  'count' is the number of password iterations performed by PBKDF2.
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_generate_derived_key()]:  returning 
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_decrypt()]:  Checking that hmac extracted from file is equal to this generated_hmac_object calculated with reconstructed_key, ciphertext and SHA256
	--------> [tuf/pycrypto_keys.py]	>>Function:  [_decrypt()]:  returning 
	-------- --------> [tuf/util.py]	>>Function:  [load_json_string()]:  Loading JSON string for data: {"keytype": "ed25519", "keyid": "49309f114b857e4b29bfbff1c1c75df59f154fbc45539b2eb30c8a867843b2cb", "keyval": {"private": "534f2710aafeb67cb3a27191c646e6c5fe6df8031714d69d2fc5639466671c47", "public": "6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433"}}
	--------> [tuf/pycrypto_keys.py]	>>Function:  [decrypt_key()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [decrypt_key()]:  returning 
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_privatekey_from_file()]:  Decrypted content of: ' /home/joan/Escriptori/TFM/TFM/demo/keys/secondary ':  {u'keytype': u'ed25519', u'keyid': u'49309f114b857e4b29bfbff1c1c75df59f154fbc45539b2eb30c8a867843b2cb', u'keyval': {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433', u'private': u'534f2710aafeb67cb3a27191c646e6c5fe6df8031714d69d2fc5639466671c47'}}
	--------> [tuf/repository_lib.py]	>>Function:  [import_ed25519_privatekey_from_file()]:  returning 
	[uptane/common.py]	>>Function:  [canonical_key_from_pub_and_pri()]:  Turn both keys into canonical key matching tuf.formats.ANYKEY_SCHEMA. key_pub and key_pri
	[uptane/common.py]	>>Function:  [canonical_key_from_pub_and_pri()]:  Returning unique key
	[uptane/common.py]	>>Function:  [canonical_key_from_pub_and_pri()]:  Returning key
	[demo/demo_secondary.py]	>>Function:  [clean_slate(use_new_keys, vin, ecu_serial, primary_host, primary_port)]:  Generate a trusted initial time for the Primary
	[demo/demo_secondary.py]	>>Function:  [create_secondary_pinning_file()]:  Load the template pinned.json file and save a filled in version that points to the client's own directory
	-------->[demo/__init__.py]	>>Action Perfomed:  [get_random_string()]:  Getting random string with length: 5
	[uptane/common.py]	>>Function:  [create_directory_structure_for_client()]:  Creates a directory structure for a client, including current and previous metadata directories
	[uptane/common.py]	>>Function:  [create_directory_structure_for_client()]:  Returning...
	--------> [uptane/clients/secondary.py]	>>Function:  [Secondary.__init__()]:  This class contains the necessary code to perform Uptane validation of images and metadata, and core functionality supporting distribution of metadata and images to Secondary ECUs, combining ECU Manifests into a Vehicle Manifest and signing it, combining tokens for a Timeserver request, validating the response, etc.
	--------> [tuf/client/updater.py]	>>Function:  [Updater.__init__()]:  Constructor. Instantiating an updater object reads pinned.json into memory and instantiates a SingleRepoUpdater object for each repository entry in the pinned.json metadata. This causes all the metadata files for the files for the top- level roles to be read from disk, including the key and role information for the delegated targets of 'targets'.  The actual metadata for delegated roles is not loaded in __init__.  The metadata for these delegated roles, including nested delegated roles, are loaded, updated, and saved to the 'self.metadata' store by the target methods, like all_targets() and targets_of_role().
	--------> [tuf/client/updater.py]	>>Function:  [Updater.__init__()]:  loading pinned.json required per TAP #4
	--------> [tuf/client/updater.py]	>>Function:  [Updater._load_pinned_metadata()]:  Loading pinned metadata...
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  Loading JSON file for filepath: /home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/metadata/pinned.json
	-------- --------> [tuf/util.py]	>>Function:  [load_json_file()]:  returning 
	--------> [tuf/client/updater.py]	>>Function:  [Updater._load_pinned_metadata()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Constructor. Instantiating an updater object causes all the metadata files for the top-level roles to be read from disk, including the key and role information for the delegated targets of 'targets'. The actual metadata for delegated roles is not loaded in __init__.  The metadata for these delegated roles, including nested delegated roles, are loaded, updated, and saved to the 'self.metadata' store by the target methods, like all_targets() and targets_of_role().
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Saving the validated arguments: repository_name: director and repository_mirrors: [u'file:////home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/unverified/director']
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Storing the trusted metadata read from disk: current and previous
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Setting the path for the current set of metadata files
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Setting the path for the previous set of metadata files
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Loading current and previous metadata
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: root
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	-------- --------> [tuf/util.py]	>>Function:  [load_file()]:  Loading file for filepath: /home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/metadata/director/current/root.der
	-------- --------> [tuf/util.py]	>>Function:  [load_file()]:  returning 
	-------- --------> [tuf/util.py]	>>Function:  [load_der_file()]:  Loading DER file for filepath: /home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/metadata/director/current/root.der
	-------- --------> [tuf/util.py]	>>Function:  [load_der_file()]:  returning 
	-------- --------> [tuf/util.py]	>>Function:  [load_der_string()]:  Loading DER string for data: ?
	-------- --------> [tuf/util.py]	>>Function:  [load_der_string()]:  returning 
	--------> [tuf/asn1_codec.py]	>>Function:  [convert_signed_der_to_dersigned_json(der_data)]:  Converting signed der to dersigned json. der_data: ?
	--------> [tuf/asn1_codec.py]	>>Function:  [_ensure_valid_metadata_type_for_asn1(metadata_type)]:  Ensuring valid metadata type for asn1. metadata_type: root
	--------> [tuf/asn1_codec.py]	>>Function:  [convert_signed_der_to_dersigned_json(der_data)]:  returning 
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Extracting the 'signed' role object from 'metadata_signable'
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving it in metadata store
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._rebuild_key_and_role_db()]:  Non-public method that rebuilds the key and role databases from the currently trusted 'root' metadata object extracted from 'root.json'. This private method is called when a new\/updated 'root' metadata file is loaded. This method will only store the role information of the top-level roles (i.e., 'root', 'targets', 'snapshot', 'timestamp').
	--------> [tuf/keydb.py]	>>Function:  [create_keydb_from_root_metadata(root_metadata, repository_name)]:  Creating keydb from metadata: {u'_type': u'Root', u'roles': {u'snapshot': {u'threshold': 1, u'keyids': [u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97']}, u'root': {u'threshold': 1, u'keyids': [u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2']}, u'targets': {u'threshold': 1, u'keyids': [u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6']}, u'timestamp': {u'threshold': 1, u'keyids': [u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc']}}, u'keys': {u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'}}, u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'}}, u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'}}, u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'}}}, u'expires': u'2021-03-05T01:58:08Z', u'version': 1, u'consistent_snapshot': False, u'compression_algorithms': [u'gz']} repository_name: director
	--------> [tuf/keydb.py]	>>Function:  [create_keydb(repository_name)]:  Create new keyDB for repository_name: director
	--------> [tuf/keydb.py]	>>Function:  [create_keydb(repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'}, u'keytype': u'ed25519', u'keyid': '630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'}, u'keytype': u'ed25519', u'keyid': '333d003373875f2e32c1ebc85c69e3b5a5281ab4da222486a095afdb7ed1be0b528948609b59172c68f6a4f707c1ce7a893d13a2243925a28923d315a5f33386', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'}, u'keytype': u'ed25519', u'keyid': '422aee4485e7f3357a04516cff9b61192da81547e4d43998a31a7b77f0ef20b5e41f47a3cdc6259b849d8ba6d89001f4dfddfc7605fd51b2309369bc14bafafe', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'}, u'keytype': u'ed25519', u'keyid': 'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'}, u'keytype': u'ed25519', u'keyid': 'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'}, u'keytype': u'ed25519', u'keyid': 'fb89d7b68f2baee108b95cfe4f13fb87237012ee787a4d18b1a24550f8969ca8034289fe2ffd22d7fcb2a51f537568e5437b25d2c4c41dca6b05499f02c622f4', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'}, u'keytype': u'ed25519', u'keyid': '833224784cbc56f947436c990c127770bd7fddeb8346bade602320542dc260cb059102ad210dba36a2fa5baacd81c89198a0f41db04c961512ce8be78c5251e2', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: director key_dict: {u'keyval': {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'}, u'keytype': u'ed25519', u'keyid': 'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [create_keydb_from_root_metadata(root_metadata, repository_name)]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [create_roledb_from_root_metadata()]:  Creating roledb from root metadata: {u'_type': u'Root', u'roles': {u'snapshot': {u'threshold': 1, u'keyids': [u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97']}, u'root': {u'threshold': 1, u'keyids': [u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2']}, u'targets': {u'threshold': 1, u'keyids': [u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6']}, u'timestamp': {u'threshold': 1, u'keyids': [u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc']}}, u'keys': {u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'99ef8790687ca252c4677a80a34e401efb7e17ccdf9b0fcb5f1bc3260c432cb9'}}, u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'd1ab5126fd6f0e30944910e81c0448044dfe9d5a39f478212b2afa913bb7ca7c'}}, u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'228342cc8b78a65b8840ef5691a693d8c368e053a7e8e8f85faf7c83eff1e1d2'}}, u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f3b4c231520580eca92e17ae1581a708f606f72d43cc200af493afeec22a5e79'}}}, u'expires': u'2021-03-05T01:58:08Z', u'version': 1, u'consistent_snapshot': False, u'compression_algorithms': [u'gz']} repository_name: director
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: root with roleinfo: {u'signatures': [], u'keyids': [u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2'], u'expires': u'2021-03-05T01:58:08Z', u'partial_loaded': False, u'version': 1, u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name director
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: root
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  root
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'keyids': [u'fdba7eaa358fa5a8113a789f60c4a6ce29c4478d8d8eff3e27d1d77416696ab2'], u'expires': u'2021-03-05T01:58:08Z', u'partial_loaded': False, u'version': 1, u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  director
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: snapshot with roleinfo: {u'signatures': [], u'partial_loaded': False, u'keyids': [u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name director
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: snapshot
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  snapshot
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'partial_loaded': False, u'keyids': [u'f93cfcf33d335ff43654ec6047e0a18dd5595ee3de53136b94c9c756788a0f97'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  director
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: targets with roleinfo: {u'paths': {}, u'signatures': [], u'partial_loaded': False, u'keyids': [u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6'], u'compressions': [u''], u'delegations': {u'keys': {}, u'roles': []}, u'threshold': 1, u'signing_keyids': []} with repository_name director
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: targets
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  targets
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'paths': {}, u'signatures': [], u'partial_loaded': False, u'keyids': [u'630cf584f392430b2119a4395e39624e86f5e5c5374507a789be5cf35bf090d6'], u'compressions': [u''], u'delegations': {u'keys': {}, u'roles': []}, u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  director
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: timestamp with roleinfo: {u'signatures': [], u'partial_loaded': False, u'keyids': [u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name director
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: timestamp
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  timestamp
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'partial_loaded': False, u'keyids': [u'da9c65c96c5c4072f6984f7aa81216d776aca6664d49cb4dfafbc7119320d9cc'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  director
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [create_roledb_from_root_metadata()]:  returning 
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: targets
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: snapshot
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: timestamp
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: root
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: targets
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: snapshot
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: timestamp
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Current and previous metadata loaded
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Returning from __init__...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Constructor. Instantiating an updater object causes all the metadata files for the top-level roles to be read from disk, including the key and role information for the delegated targets of 'targets'. The actual metadata for delegated roles is not loaded in __init__.  The metadata for these delegated roles, including nested delegated roles, are loaded, updated, and saved to the 'self.metadata' store by the target methods, like all_targets() and targets_of_role().
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Saving the validated arguments: repository_name: imagerepo and repository_mirrors: [u'file:////home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/unverified/imagerepo']
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Storing the trusted metadata read from disk: current and previous
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Setting the path for the current set of metadata files
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Setting the path for the previous set of metadata files
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Loading current and previous metadata
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: root
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	-------- --------> [tuf/util.py]	>>Function:  [load_file()]:  Loading file for filepath: /home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/metadata/imagerepo/current/root.der
	-------- --------> [tuf/util.py]	>>Function:  [load_file()]:  returning 
	-------- --------> [tuf/util.py]	>>Function:  [load_der_file()]:  Loading DER file for filepath: /home/joan/Escriptori/TFM/TFM/temp_secondaryHYWG0/metadata/imagerepo/current/root.der
	-------- --------> [tuf/util.py]	>>Function:  [load_der_file()]:  returning 
	-------- --------> [tuf/util.py]	>>Function:  [load_der_string()]:  Loading DER string for data: ?
	-------- --------> [tuf/util.py]	>>Function:  [load_der_string()]:  returning 
	--------> [tuf/asn1_codec.py]	>>Function:  [convert_signed_der_to_dersigned_json(der_data)]:  Converting signed der to dersigned json. der_data: ?
	--------> [tuf/asn1_codec.py]	>>Function:  [_ensure_valid_metadata_type_for_asn1(metadata_type)]:  Ensuring valid metadata type for asn1. metadata_type: root
	--------> [tuf/asn1_codec.py]	>>Function:  [convert_signed_der_to_dersigned_json(der_data)]:  returning 
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Extracting the 'signed' role object from 'metadata_signable'
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving it in metadata store
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._rebuild_key_and_role_db()]:  Non-public method that rebuilds the key and role databases from the currently trusted 'root' metadata object extracted from 'root.json'. This private method is called when a new\/updated 'root' metadata file is loaded. This method will only store the role information of the top-level roles (i.e., 'root', 'targets', 'snapshot', 'timestamp').
	--------> [tuf/keydb.py]	>>Function:  [create_keydb_from_root_metadata(root_metadata, repository_name)]:  Creating keydb from metadata: {u'_type': u'Root', u'roles': {u'snapshot': {u'threshold': 1, u'keyids': [u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99']}, u'root': {u'threshold': 1, u'keyids': [u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290']}, u'targets': {u'threshold': 1, u'keyids': [u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596']}, u'timestamp': {u'threshold': 1, u'keyids': [u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a']}}, u'keys': {u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'}}, u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'}}, u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'}}, u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'}}}, u'expires': u'2021-03-05T01:57:53Z', u'version': 1, u'consistent_snapshot': False, u'compression_algorithms': [u'gz']} repository_name: imagerepo
	--------> [tuf/keydb.py]	>>Function:  [create_keydb(repository_name)]:  Create new keyDB for repository_name: imagerepo
	--------> [tuf/keydb.py]	>>Function:  [create_keydb(repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'}, u'keytype': u'ed25519', u'keyid': '94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'}, u'keytype': u'ed25519', u'keyid': '0b8c67edcf307f5bdc30ebc441086fe58f9320f4b5e04f2cefbfa8998868d32d85a17da47691db4e6fb2f3440ca9a03b69d07588a32c5f555f769c0a21351648', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'}, u'keytype': u'ed25519', u'keyid': '6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'}, u'keytype': u'ed25519', u'keyid': 'deb7ea2937f68b7f4067593fedf0004858c48c44f7195a72da7239fe558b32f824ef4db756cefe8be61ae483fa2c4d6dcb0286f0dd9edc7a7f8f496a5999e2d1', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'}, u'keytype': u'ed25519', u'keyid': 'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'}, u'keytype': u'ed25519', u'keyid': '43aee7e76e88246ea88931fd9df636c3e0851b448860bb1b3d8f4e066641e2523d3e46c1074226d6f9877c57024a9f3ff05bf3cc8c7377933078e1a6c0bf027c', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Constructing TUF key dictionary for key_metadata: {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'}}
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  Converting 'key_value' from 'key_metadata' to 'tuf.formats.KEY_SCHEMA' and generating its hash
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} hash_algorithm: sha256
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  [inside for loop] - for hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  Getting keyid for keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} hash_algorithm: sha512
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  Return a dictionary conformant to 'tuf.formats.KEY_SCHEMA'keytype: ed25519 key_value: {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'} private: False
	-------- --------> [tuf/keys.py]	>>Function:  [format_keyval_to_metadata()]:  returning 
	-------- --------> [tuf/hash.py]	>>Function:  [digest()]:  Provide the caller with the ability to create digest objects without having to worry about hash library availability or which library to use. The caller also has the option of specifying which hash algorithm and/or library to use.
	-------- --------> [tuf/keys.py]	>>Function:  [_get_keyid()]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [format_metadata_to_key()]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'}, u'keytype': u'ed25519', u'keyid': 'af583431e6fd4ea9e8c0743aa7d8132d6a8f5c0a9dc44e60766d0dd7e3691055635b78065b4821a01f8a02d58fc24202ebaa3c3a9e3bc2acaf12b7301b214756', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  Adding key to keyDB for repository_name: imagerepo key_dict: {u'keyval': {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'}, u'keytype': u'ed25519', u'keyid': 'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596', u'keyid_hash_algorithms': [u'sha256', u'sha512']} keyid: None
	--------> [tuf/keydb.py]	>>Function:  [add_key(key_dict, keyid, repository_name)]:  returning 
	--------> [tuf/keydb.py]	>>Function:  [create_keydb_from_root_metadata(root_metadata, repository_name)]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [create_roledb_from_root_metadata()]:  Creating roledb from root metadata: {u'_type': u'Root', u'roles': {u'snapshot': {u'threshold': 1, u'keyids': [u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99']}, u'root': {u'threshold': 1, u'keyids': [u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290']}, u'targets': {u'threshold': 1, u'keyids': [u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596']}, u'timestamp': {u'threshold': 1, u'keyids': [u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a']}}, u'keys': {u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'f4ac8d95cfdf65a4ccaee072ba5a48e8ad6a0c30be6ffd525aec6bc078211033'}}, u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'97c1112bbd9047b1fdb50dd638bfed6d0639e0dff2c1443f5593fea40e30f654'}}, u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'497f62d80e5b892718da8788bb549bcf8369a1460ec23d6d67d0ca099a8e8f83'}}, u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596': {u'keytype': u'ed25519', u'keyid_hash_algorithms': [u'sha256', u'sha512'], u'keyval': {u'public': u'729d9cb5f74688ef8e9a22fae1516f33ff98c7910b64bf3b66e6cfc51559840e'}}}, u'expires': u'2021-03-05T01:57:53Z', u'version': 1, u'consistent_snapshot': False, u'compression_algorithms': [u'gz']} repository_name: imagerepo
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: root with roleinfo: {u'signatures': [], u'keyids': [u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290'], u'expires': u'2021-03-05T01:57:53Z', u'partial_loaded': False, u'version': 1, u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name imagerepo
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: root
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  root
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'keyids': [u'94c836f0c45168f0a437eef0e487b910f58db4d462ae457b5730a4487130f290'], u'expires': u'2021-03-05T01:57:53Z', u'partial_loaded': False, u'version': 1, u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  imagerepo
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: snapshot with roleinfo: {u'signatures': [], u'partial_loaded': False, u'keyids': [u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name imagerepo
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: snapshot
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  snapshot
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'partial_loaded': False, u'keyids': [u'aaf05f8d054f8068bf6cb46beed7c824e2560802df462fc8681677586582ca99'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  imagerepo
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: targets with roleinfo: {u'paths': {}, u'signatures': [], u'partial_loaded': False, u'keyids': [u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596'], u'compressions': [u''], u'delegations': {u'keys': {}, u'roles': []}, u'threshold': 1, u'signing_keyids': []} with repository_name imagerepo
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: targets
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  targets
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'paths': {}, u'signatures': [], u'partial_loaded': False, u'keyids': [u'c24b457b2ca4b3c2f415efdbbebb914a0d05c5345b9889bda044362589d6f596'], u'compressions': [u''], u'delegations': {u'keys': {}, u'roles': []}, u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  imagerepo
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Adding role: timestamp with roleinfo: {u'signatures': [], u'partial_loaded': False, u'keyids': [u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []} with repository_name imagerepo
	--------> [tuf/roledb.py]	>>Function:  [_validate_rolename()]:  Validating rolename for rolename: timestamp
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for rolename:  timestamp
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for roleinfo:  {u'signatures': [], u'partial_loaded': False, u'keyids': [u'6fcd9a928358ad8ca7e946325f57ec71d50cb5977a8d02c5ab0de6765fef040a'], u'compressions': [u''], u'threshold': 1, u'signing_keyids': []}
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  Value for repository_name:  imagerepo
	--------> [tuf/roledb.py]	>>Function:  [add_role()]:  returning 
	--------> [tuf/roledb.py]	>>Function:  [create_roledb_from_root_metadata()]:  returning 
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: targets
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: snapshot
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: current metadata_role: timestamp
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: current
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: root
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: targets
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: snapshot
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Loading current or previous metadata from file if there is a local file. metadata_set: previous metadata_role: timestamp
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Validating metadata...
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  Validating metadata_set: previous
	--------> [tuf/client/updater.py]	>>Function:  [validate_metadata_set()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  Saving and constructing the full metadata path
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater._load_metadata_from_file()]:  returning...
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Current and previous metadata loaded
	--------> [tuf/client/updater.py]	>>Function:  [SingleRepoUpdater.__init__()]:  Returning from __init__...
	[demo/demo_secondary.py]	>>Function:  [register_self_with_director()]:  Send the Director a message to register our ECU serial number and Public Key.
Registering Secondary ECU Serial and Key with Director.
	[uptane/common.py]	>>Function:  [public_key_from_canonical()]:  Given a key that includes all public and private key information, return public key. key_canonical: {u'keytype': u'ed25519', u'keyid': '49309f114b857e4b29bfbff1c1c75df59f154fbc45539b2eb30c8a867843b2cb', u'keyval': {u'public': u'6b3ce84f9de678c1c4555607055398ebb2369c84800742773165c5854660c433', u'private': u'534f2710aafeb67cb3a27191c646e6c5fe6df8031714d69d2fc5639466671c47'}, u'keyid_hash_algorithms': [u'sha256', u'sha512']}
	[uptane/common.py]	>>Function:  [public_key_from_canonical()]:  Returning key_public
Secondary has been registered with the Director.
	[demo/demo_secondary.py]	>>Function:  [register_self_with_primary()]:  Send the Primary a message to register our ECU serial number TCUdemocar
Registering Secondary ECU Serial and Key with Primary.
Secondary has been registered with the Primary.

 Now simulating a Secondary that rolled off the assembly line
 and has never seen an update.
Generating this Secondary's first ECU Version Manifest and sending it to the Primary.
	[demo/demo_secondary.py]	>>Function:  [generate_signed_ecu_manifest()]:  Generating signed ecu manifest
	--------> [uptane/clients/secondary.py]	>>Function:  [Secondary.generate_signed_vehicle_manifest(self, description_of_attacks_observed)]:  Returns a signed ECU manifest indicating self.firmware_fileinfo. If the optional description_of_attacks_observed argument is provided, the ECU Manifest will include that in the ECU Manifest (attacks_detected).
	-------- --------> [tuf/keys.py]	>>Function:  [create_signature()]:  Creating signature for key_dict ? and data for create it: ?
	-------- --------> [tuf/keys.py]	>>Function:  [check_crypto_libraries()]:  Checking crypto libraries required_libraries: [u'ed25519']
	--------> [tuf/ed25519_keys.py]	>>Function:  [create_signature(public_key, private_key, data)]:  Creating signature with public_key: ? private_key: ? data: ?
	--------> [tuf/ed25519_keys.py]	>>Function:  [create_signature(public_key, private_key, data)]:  returning 
	-------- --------> [tuf/keys.py]	>>Function:  [create_signature()]:  returning 
	[demo/demo_secondary.py]	>>Function:  [submit_ecu_manifest_to_primary(signed_ecu_manifest)]:  Submitting ECU manifest to primary. signed_ecu_manifest: None
>>> 
